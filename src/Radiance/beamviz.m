function varargout = beamviz(varargin)
% BEAMVIZ M-file for beamviz.fig
%      BEAMVIZ, by itself, creates a new BEAMVIZ or raises the existing
%      singleton*.
%
%      H = BEAMVIZ returns the handle to a new BEAMVIZ or the handle to
%      the existing singleton*.
%
%      BEAMVIZ('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in BEAMVIZ.M with the given input arguments.
%
%      BEAMVIZ('Property','Value',...) creates a new BEAMVIZ or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before beamviz_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to beamviz_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help beamviz

% Last Modified by GUIDE v2.5 06-Jul-2010 11:32:06

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @beamviz_OpeningFcn, ...
                   'gui_OutputFcn',  @beamviz_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before beamviz is made visible.
function beamviz_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to beamviz (see VARARGIN)

% Choose default command line output for beamviz
handles.output = hObject;

% Update handles structure
guidata(hObject, handles);

% beamviz-related init
global BEAMVIZ_GLOBAL;
BEAMVIZ_GLOBAL.rad_filename = ''; % Radiance analysis file.
BEAMVIZ_GLOBAL.array_filename = '';
BEAMVIZ_GLOBAL.d3_filename = '';
BEAMVIZ_GLOBAL.wamike_filename = '';
BEAMVIZ_GLOBAL.wagaincal_filename = '';
BEAMVIZ_GLOBAL.radiance_analysed = [];
BEAMVIZ_GLOBAL.current_voc = 1;
BEAMVIZ_GLOBAL.beam_lo_freq = 28e3; % in Hertz
BEAMVIZ_GLOBAL.beam_hi_freq = 42e3;

% and internal fields (mostly)
BEAMVIZ_GLOBAL.handles = handles;
BEAMVIZ_GLOBAL.plot_type = 0;
% 0 --> "scene plot" using signal RMS; same as would be generated by clicking "beam" button in Radiance.
% 1 --> "scene plot", using peaks (after bandpass filtering, envelope
%       extraction and Savitzky-Golay filtering, which is similar to 35kHz
%       array + sunshine analysis).
% 2 --> radial plot, using signal RMS
% 3 --> radial plot, using signal peaks after BPF, envelope extraction, and
%       SG filtering.
BEAMVIZ_GLOBAL.min_freq = 10e3;
BEAMVIZ_GLOBAL.max_freq = 130e3;
BEAMVIZ_GLOBAL.az = 322.5; % azimuth (in degrees)
BEAMVIZ_GLOBAL.el = 30; % elevation (in deg)
BEAMVIZ_GLOBAL.def_dir = '.';

% UIWAIT makes beamviz wait for user response (see UIRESUME)
% uiwait(handles.figure1);


% --- Outputs from this function are returned to the command line.
function varargout = beamviz_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


% --- Executes on button press in popout_button.
function popout_button_Callback(hObject, eventdata, handles)
% Same as usual, but now in a figure external to the GUI (in order to allow
% user to more easily manipulate the plot).
fig_h = figure;
ax_h = axes;
update_plot(fig_h,ax_h);


% --------------------------------------------------------------------
function Untitled_1_Callback(hObject, eventdata, handles)
% hObject    handle to Untitled_1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function Untitled_2_Callback(hObject, eventdata, handles)
% hObject    handle to Untitled_2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function change_gaincal_file_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
if isempty(BEAMVIZ_GLOBAL.array_filename)
    return % Ignore request if no trial analysis is active
end
[wagaincal_filename, pathname] = uigetfile( '*.wagaincal.mat', 'Select gain calibration', BEAMVIZ_GLOBAL.def_dir );
if isequal(wagaincal_filename,0)
    return % User hit Cancel button.
else
    wagaincal_filename = [pathname wagaincal_filename];
end
fprintf( 'Reading gain calibration file... ');
try
    gf = load('-MAT', wagaincal_filename );
    if ~isfield(gf, 'G' )
        fprintf('FAIL!\n');
        return
    end
    fprintf('Done.\n');
catch
    fprintf( 'FAIL!\n' );
    return
end
BEAMVIZ_GLOBAL.wagaincal_filename = wagaincal_filename;
BEAMVIZ_GLOBAL.G = gf.G;
if isfield(gf,'freq_divs')
    BEAMVIZ_GLOBAL.freq_divs = gf.freq_divs;
end
dmarks = strfind( BEAMVIZ_GLOBAL.wagaincal_filename, '\' );
if isempty(dmarks)
    dmarks = [0];
end
set(BEAMVIZ_GLOBAL.handles.wagaincal_filename_box, 'String', BEAMVIZ_GLOBAL.wagaincal_filename(dmarks(end)+1:end) );
set(BEAMVIZ_GLOBAL.handles.wagaincal_filename_box, 'TooltipString', BEAMVIZ_GLOBAL.wagaincal_filename );
update_plot;


% --------------------------------------------------------------------
function view_gain_adj_mag_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
if isempty(BEAMVIZ_GLOBAL.wagaincal_filename)
    return % Ignore empty states
end
fig_h = figure;
ax_h = axes;
plot( ax_h, BEAMVIZ_GLOBAL.G(:,1)/1e3, BEAMVIZ_GLOBAL.G(:,2:end), '.-' );
axis( ax_h, 'tight' );
xlabel( 'kHz' );
ylabel( '|H|' );
title( 'gain magnitude compensation' );
for k = 1:BEAMVIZ_GLOBAL.num_mics
    % Mark channel numbers at the start and stop of the traces.
    text(BEAMVIZ_GLOBAL.G(end,1)/1e3,BEAMVIZ_GLOBAL.G(end,k+1), sprintf('% 3d',k) );
    text(BEAMVIZ_GLOBAL.G(1,1)/1e3,BEAMVIZ_GLOBAL.G(1,k+1), sprintf('% 3d',k) );
end


% --------------------------------------------------------------------
function open_radfile_request_Callback(hObject, eventdata, handles)
% Confirmation dialog
ButtonName=questdlg( 'Open (existing) Radiance analysis results?', ...
                     'Open Trial Confirmation', 'Yes', 'No', 'No' );
if ~strcmpi(ButtonName,'Yes')
    return
end

global BEAMVIZ_GLOBAL;

[fname, pathname] = uigetfile( '*_rad.mat', 'Select a Radiance analysis file.', BEAMVIZ_GLOBAL.def_dir );
if isequal(fname,0)
    return % User hit Cancel button; abort silently.
end

try
    rf = load('-MAT',[pathname fname]);
catch
    fprintf( 'Error occurred while attempting to open %s\n', [pathname fname] );
    return % error; do nothing.
end
if ~isfield(rf,'radiance_analysed')
    fprintf( 'File contents are invalid; failed to load %s\n', [pathname fname] );
    return % error
end
if all(all(isnan(rf.radiance_analysed.T_start)))
    fprintf( 'No vocalizations marked in given Radiance analysis file.\nIgnoring.\n' );
    return % abort loading
end
rad_filename = [pathname fname];

fprintf( 'Loaded %s; attempting to start a beam visualization session...\n', [pathname fname] );

% Before trying much, we need to confirm availability of array data file,
% d3_analysed file, and microphone position and gain calibration.
D = dir(rf.radiance_analysed.data_file);
if isempty(D)
    [array_filename, pathname] = uigetfile( '*.bin', 'Failed to auto-load; Select raw array data file', BEAMVIZ_GLOBAL.def_dir );
    if isequal(array_filename,0)
        return % User hit Cancel button.
    else
        rf.radiance_analysed.data_file = [pathname array_filename];
    end
end
fprintf( 'Reading array data file... ' );
[F,t,Ts,params] = loadafile( rf.radiance_analysed.data_file );
if isempty(F)
    fprintf( 'FAIL!\n' );
    return
else
    fprintf( 'Done.\n' );
end

D = dir(rf.radiance_analysed.d3_file);
if isempty(D)
    [d3_filename, pathname] = uigetfile( '*_d3.mat', 'Failed to auto-load; Select d3 analysed file', BEAMVIZ_GLOBAL.def_dir );
    if isequal(d3_filename,0)
        return % User hit Cancel button.
    else
        rf.radiance_analysed.d3_file = [pathname d3_filename];
    end
end
fprintf( 'Reading d3-processed file... ' );
try
    d3f = load('-MAT',rf.radiance_analysed.d3_file);
    if ~isfield( d3f, 'd3_analysed' )
        fprintf('FAIL!\n');
        return
    end
    fprintf( 'Done.\n' );
catch
    fprintf( 'FAIL!\n' );
    return
end

D = dir(rf.radiance_analysed.wamike_file);
if isempty(D)
    [wamike_filename, pathname] = uigetfile( '*.wamike.txt', 'Failed to auto-load; Select microphone position calibration', BEAMVIZ_GLOBAL.def_dir );
    if isequal(wamike_filename,0)
        return % User hit Cancel button.
    else
        rf.radiance_analysed.wamike_file = [pathname wamike_filename];
    end
end
fprintf( 'Reading mike position file... ' );
try
    mike_pos = load('-ASCII', rf.radiance_analysed.wamike_file );
    if size(mike_pos,2) ~= 3
        fprintf('FAIL!\n');
        return
    end
    fprintf( 'Done.\n' );
catch
    fprintf( 'FAIL!\n' );
    return
end

D = dir(rf.radiance_analysed.wagaincal_file);
if isempty(D)
    [wagaincal_filename, pathname] = uigetfile( '*.wagaincal.mat', 'Failed to auto-load; Select gain calibration', BEAMVIZ_GLOBAL.def_dir );
    if isequal(wagaincal_filename,0)
        return % User hit Cancel button.
    else
        rf.radiance_analysed.wagaincal_file = [pathname wagaincal_filename];
    end
end
fprintf( 'Reading gain calibration file... ');
try
    gf = load('-MAT', rf.radiance_analysed.wagaincal_file );
    if ~isfield(gf, 'G' )
        fprintf('FAIL!\n');
        return
    end
    fprintf('Done.\n');
catch
    fprintf( 'FAIL!\n' );
    return
end

% Commit to filenames
BEAMVIZ_GLOBAL.rad_filename = rad_filename;
BEAMVIZ_GLOBAL.array_filename = rf.radiance_analysed.data_file;
BEAMVIZ_GLOBAL.d3_filename = rf.radiance_analysed.d3_file;
BEAMVIZ_GLOBAL.wamike_filename = rf.radiance_analysed.wamike_file;
BEAMVIZ_GLOBAL.wagaincal_filename = rf.radiance_analysed.wagaincal_file;

% Copy relevant fields from opened analysis file
BEAMVIZ_GLOBAL.timestamp = rf.radiance_analysed.timestamp;
BEAMVIZ_GLOBAL.bat_ID = rf.radiance_analysed.bat_ID;
BEAMVIZ_GLOBAL.owner = rf.radiance_analysed.owner;
BEAMVIZ_GLOBAL.num_vocs = rf.radiance_analysed.num_vocs;
BEAMVIZ_GLOBAL.num_mics = rf.radiance_analysed.num_mics;
BEAMVIZ_GLOBAL.T_start = rf.radiance_analysed.T_start;
BEAMVIZ_GLOBAL.F_start = rf.radiance_analysed.F_start;
BEAMVIZ_GLOBAL.T_stop = rf.radiance_analysed.T_stop;
BEAMVIZ_GLOBAL.F_stop = rf.radiance_analysed.F_stop;

% And stuff from data and calibration files
BEAMVIZ_GLOBAL.mike_pos = mike_pos;
BEAMVIZ_GLOBAL.bat = d3f.d3_analysed.object(1).video; % Assuming bat trajectory is that of first object.
BEAMVIZ_GLOBAL.objects = d3f.d3_analysed.object(2:end);
BEAMVIZ_GLOBAL.vid_fps = d3f.d3_analysed.fvideo;
BEAMVIZ_GLOBAL.vid_start_frame = d3f.d3_analysed.startframe;
BEAMVIZ_GLOBAL.G = gf.G;
if isfield(gf,'freq_divs')
    BEAMVIZ_GLOBAL.freq_divs = gf.freq_divs;
end

if isfield(params, 'sample_period')
    BEAMVIZ_GLOBAL.samp_period = params.sample_period;
else
    BEAMVIZ_GLOBAL.samp_period = Ts;
end

% And finally, the raw array data itself
BEAMVIZ_GLOBAL.F = F;
BEAMVIZ_GLOBAL.t = t;

% Environmental parameters
BEAMVIZ_GLOBAL.temp = 22; % deg C
BEAMVIZ_GLOBAL.rel_humid = 50; % percent relative humidity
BEAMVIZ_GLOBAL.spd_sound = 343; % m/s (note that this is related to temperature and RH).

% Init or adjust accordingly several internal GUI parameters
BEAMVIZ_GLOBAL.plot_type = 0; % reset to "scene plot, RMS"
BEAMVIZ_GLOBAL.current_voc = 1;
BEAMVIZ_GLOBAL.az = 322.5;
BEAMVIZ_GLOBAL.el = 30;
BEAMVIZ_GLOBAL.min_freq = 10e3;
BEAMVIZ_GLOBAL.max_freq = 130e3;
BEAMVIZ_GLOBAL.current_voc = 1;
BEAMVIZ_GLOBAL.beam_lo_freq = 28e3; % in Hertz
BEAMVIZ_GLOBAL.beam_hi_freq = 42e3;
BEAMVIZ_GLOBAL.ignore_ch = []; % By default, do not mark any microphone channels for ignoring.

% calculate now bandwidth of viewing frequencies to simplify work later
bw = (BEAMVIZ_GLOBAL.beam_hi_freq-BEAMVIZ_GLOBAL.beam_lo_freq)*1e-3; % in kHz

% Refresh relevant GUI widgets
set(BEAMVIZ_GLOBAL.handles.low_freq_box, 'String', sprintf( '%.2f', BEAMVIZ_GLOBAL.beam_lo_freq*1e-3 ));
set(BEAMVIZ_GLOBAL.handles.high_freq_box, 'String', sprintf( '%.2f', BEAMVIZ_GLOBAL.beam_hi_freq*1e-3 ));
set(BEAMVIZ_GLOBAL.handles.plot_type_menu, 'Value', BEAMVIZ_GLOBAL.plot_type+1);
set(BEAMVIZ_GLOBAL.handles.voc_num_box, 'String', num2str( BEAMVIZ_GLOBAL.current_voc ));
set(BEAMVIZ_GLOBAL.handles.bw_box, 'String', sprintf( '%.2f', bw ));
set(BEAMVIZ_GLOBAL.handles.az_box, 'String', sprintf( '%.2f', BEAMVIZ_GLOBAL.az ));
set(BEAMVIZ_GLOBAL.handles.el_box, 'String', sprintf( '%.2f', BEAMVIZ_GLOBAL.el ));
set(BEAMVIZ_GLOBAL.handles.voc_slider,'Min',1);
if BEAMVIZ_GLOBAL.num_vocs == 1
    set(BEAMVIZ_GLOBAL.handles.voc_slider,'Max',1.1);
else
    set(BEAMVIZ_GLOBAL.handles.voc_slider,'Max',BEAMVIZ_GLOBAL.num_vocs);
end
set(BEAMVIZ_GLOBAL.handles.voc_slider,'Value',[1]);
set(BEAMVIZ_GLOBAL.handles.freq_slider,'Min',BEAMVIZ_GLOBAL.min_freq*1e-3+bw/2);
set(BEAMVIZ_GLOBAL.handles.freq_slider,'Max',BEAMVIZ_GLOBAL.max_freq*1e-3-bw/2);
set(BEAMVIZ_GLOBAL.handles.freq_slider,'SliderStep',[0.01 0.1]);
set(BEAMVIZ_GLOBAL.handles.freq_slider,'Value',[BEAMVIZ_GLOBAL.beam_lo_freq*1e-3+bw/2]);

% Session info box
dmarks = strfind( BEAMVIZ_GLOBAL.rad_filename, '\' ); % Assuming we are on Windows >_<
if isempty(dmarks)
    dmarks = [0];
end
set(BEAMVIZ_GLOBAL.handles.rad_filename_box, 'String', BEAMVIZ_GLOBAL.rad_filename(dmarks(end)+1:end) );
set(BEAMVIZ_GLOBAL.handles.rad_filename_box, 'TooltipString', BEAMVIZ_GLOBAL.rad_filename );
dmarks = strfind( BEAMVIZ_GLOBAL.array_filename, '\' );
if isempty(dmarks)
    dmarks = [0];
end
set(BEAMVIZ_GLOBAL.handles.array_filename_box, 'String', BEAMVIZ_GLOBAL.array_filename(dmarks(end)+1:end) );
set(BEAMVIZ_GLOBAL.handles.array_filename_box, 'TooltipString', BEAMVIZ_GLOBAL.array_filename );
dmarks = strfind( BEAMVIZ_GLOBAL.d3_filename, '\' );
if isempty(dmarks)
    dmarks = [0];
end
set(BEAMVIZ_GLOBAL.handles.d3_filename_box, 'String', BEAMVIZ_GLOBAL.d3_filename(dmarks(end)+1:end) );
set(BEAMVIZ_GLOBAL.handles.d3_filename_box, 'TooltipString', BEAMVIZ_GLOBAL.d3_filename );
dmarks = strfind( BEAMVIZ_GLOBAL.wamike_filename, '\' );
if isempty(dmarks)
    dmarks = [0];
end
set(BEAMVIZ_GLOBAL.handles.wamike_filename_box, 'String', BEAMVIZ_GLOBAL.wamike_filename(dmarks(end)+1:end) );
set(BEAMVIZ_GLOBAL.handles.wamike_filename_box, 'TooltipString', BEAMVIZ_GLOBAL.wamike_filename );
dmarks = strfind( BEAMVIZ_GLOBAL.wagaincal_filename, '\' );
if isempty(dmarks)
    dmarks = [0];
end
set(BEAMVIZ_GLOBAL.handles.wagaincal_filename_box, 'String', BEAMVIZ_GLOBAL.wagaincal_filename(dmarks(end)+1:end) );
set(BEAMVIZ_GLOBAL.handles.wagaincal_filename_box, 'TooltipString', BEAMVIZ_GLOBAL.wagaincal_filename );

update_plot; % Let's do this shit.


% --------------------------------------------------------------------
function exit_beamviz_request_Callback(hObject, eventdata, handles)
ButtonName=questdlg( 'Are you sure?', ...
                     'Exit Confirmation', 'Yes', 'No', 'No' );
if ~strcmpi(ButtonName,'Yes')
    return
end
clear global BEAMVIZ_GLOBAL;
close(gcf);  % and then close the application.


% --- Executes on selection change in plot_type_menu.
function plot_type_menu_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
BEAMVIZ_GLOBAL.plot_type = floor(get(hObject,'Value'))-1;
update_plot;


% --- Executes during object creation, after setting all properties.
function plot_type_menu_CreateFcn(hObject, eventdata, handles)
% hObject    handle to plot_type_menu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


function rad_filename_box_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
dmarks = strfind( BEAMVIZ_GLOBAL.rad_filename, '\' ); % Assuming we are on Windows >_<
if isempty(dmarks)
    dmarks = [0];
end
set(BEAMVIZ_GLOBAL.handles.rad_filename_box, 'String', BEAMVIZ_GLOBAL.rad_filename(dmarks(end)+1:end) );


% --- Executes during object creation, after setting all properties.
function rad_filename_box_CreateFcn(hObject, eventdata, handles)
% hObject    handle to rad_filename_box (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


function wamike_filename_box_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
dmarks = strfind( BEAMVIZ_GLOBAL.wamike_filename, '\' );
if isempty(dmarks)
    dmarks = [0];
end
set(BEAMVIZ_GLOBAL.handles.wamike_filename_box, 'String', BEAMVIZ_GLOBAL.wamike_filename(dmarks(end)+1:end) );


% --- Executes during object creation, after setting all properties.
function wamike_filename_box_CreateFcn(hObject, eventdata, handles)
% hObject    handle to wamike_filename_box (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


function wagaincal_filename_box_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
dmarks = strfind( BEAMVIZ_GLOBAL.wagaincal_filename, '\' );
if isempty(dmarks)
    dmarks = [0];
end
set(BEAMVIZ_GLOBAL.handles.wagaincal_filename_box, 'String', BEAMVIZ_GLOBAL.wagaincal_filename(dmarks(end)+1:end) );


% --- Executes during object creation, after setting all properties.
function wagaincal_filename_box_CreateFcn(hObject, eventdata, handles)
% hObject    handle to wagaincal_filename_box (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --------------------------------------------------------------------
function about_monologue_Callback(hObject, eventdata, handles)
msgbox(sprintf('Scott Livingston\nAuditory Neuroethology Lab (or the "Batlab")\nU. Maryland, College Park\n(c) 2009, 2010'),'beamviz, sonar beam visualization','modal');


% --- Executes on slider movement.
function voc_slider_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
if get(hObject,'Value') > BEAMVIZ_GLOBAL.current_voc
    BEAMVIZ_GLOBAL.current_voc = ceil(get(hObject,'Value'));
else
    BEAMVIZ_GLOBAL.current_voc = floor(get(hObject,'Value'));
end
set(BEAMVIZ_GLOBAL.handles.voc_num_box,'String',num2str( BEAMVIZ_GLOBAL.current_voc ) );
set(BEAMVIZ_GLOBAL.handles.voc_slider,'Value',BEAMVIZ_GLOBAL.current_voc );
update_plot;


% --- Executes during object creation, after setting all properties.
function voc_slider_CreateFcn(hObject, eventdata, handles)
% hObject    handle to voc_slider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: slider controls usually have a light gray background.
if isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor',[.9 .9 .9]);
end


% --- Executes on slider movement.
function freq_slider_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
f_c = get(hObject,'Value')*1e3; % Center frequency, in Hertz
bw = BEAMVIZ_GLOBAL.beam_hi_freq - BEAMVIZ_GLOBAL.beam_lo_freq;
BEAMVIZ_GLOBAL.beam_lo_freq = f_c-bw/2;
BEAMVIZ_GLOBAL.beam_hi_freq = f_c+bw/2;
set(BEAMVIZ_GLOBAL.handles.low_freq_box, 'String', sprintf( '%.2f', BEAMVIZ_GLOBAL.beam_lo_freq*1e-3 ));
set(BEAMVIZ_GLOBAL.handles.high_freq_box, 'String', sprintf( '%.2f', BEAMVIZ_GLOBAL.beam_hi_freq*1e-3 ));
update_plot;


% --- Executes during object creation, after setting all properties.
function freq_slider_CreateFcn(hObject, eventdata, handles)
% hObject    handle to freq_slider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: slider controls usually have a light gray background.
if isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor',[.9 .9 .9]);
end


function voc_num_box_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
requested_voc = str2num( get(hObject,'String') );
if isempty(requested_voc) || requested_voc < 1 || requested_voc > BEAMVIZ_GLOBAL.num_vocs
    set(BEAMVIZ_GLOBAL.handles.voc_num_box,'String',num2str( BEAMVIZ_GLOBAL.current_voc ) );
    return % Invalid request; ignore.
end
BEAMVIZ_GLOBAL.current_voc = floor(requested_voc);
set(BEAMVIZ_GLOBAL.handles.voc_num_box,'String',num2str( BEAMVIZ_GLOBAL.current_voc ) );
set(BEAMVIZ_GLOBAL.handles.voc_slider,'Value',BEAMVIZ_GLOBAL.current_voc );
update_plot;


% --- Executes during object creation, after setting all properties.
function voc_num_box_CreateFcn(hObject, eventdata, handles)
% hObject    handle to voc_num_box (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


function bw_box_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
f_c = (BEAMVIZ_GLOBAL.beam_hi_freq + BEAMVIZ_GLOBAL.beam_lo_freq)/2; % Center frequency, in Hertz
bw = BEAMVIZ_GLOBAL.beam_hi_freq - BEAMVIZ_GLOBAL.beam_lo_freq;
requested_bw = str2num( get(hObject,'String') )*1e3;
if isempty(requested_bw) || requested_bw < eps
    set(BEAMVIZ_GLOBAL.handles.bw_box, 'String', sprintf( '%.2f', bw ));
    return % Invalid request; ignore
end
bw = requested_bw;
if f_c-bw/2 < BEAMVIZ_GLOBAL.min_freq
    bw = 2*(f_c - BEAMVIZ_GLOBAL.min_freq);
end
if f_c+bw/2 > BEAMVIZ_GLOBAL.max_freq
    bw = 2*(BEAMVIZ_GLOBAL.max_freq - f_c);
end
BEAMVIZ_GLOBAL.beam_lo_freq = f_c-bw/2;
BEAMVIZ_GLOBAL.beam_hi_freq = f_c+bw/2;
set(BEAMVIZ_GLOBAL.handles.low_freq_box, 'String', sprintf( '%.2f', BEAMVIZ_GLOBAL.beam_lo_freq*1e-3 ));
set(BEAMVIZ_GLOBAL.handles.high_freq_box, 'String', sprintf( '%.2f', BEAMVIZ_GLOBAL.beam_hi_freq*1e-3 ));
set(BEAMVIZ_GLOBAL.handles.freq_slider,'Min',(BEAMVIZ_GLOBAL.min_freq+bw/2)*1e-3);
set(BEAMVIZ_GLOBAL.handles.freq_slider,'Max',(BEAMVIZ_GLOBAL.max_freq-bw/2)*1e-3);
set(BEAMVIZ_GLOBAL.handles.bw_box, 'String', sprintf( '%.2f', bw*1e-3 ));
update_plot;


% --- Executes during object creation, after setting all properties.
function bw_box_CreateFcn(hObject, eventdata, handles)
% hObject    handle to bw_box (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function az_box_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
requested_az = str2num(get(hObject,'String'));
if isempty(requested_az)
    set(BEAMVIZ_GLOBAL.handles.az_box, 'String', sprintf( '%.2f', BEAMVIZ_GLOBAL.az ));
    return % Given azimuth invalid; ignore.
end
BEAMVIZ_GLOBAL.az = requested_az(1);
update_plot;


% --- Executes during object creation, after setting all properties.
function az_box_CreateFcn(hObject, eventdata, handles)
% hObject    handle to az_box (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


function el_box_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
requested_el = str2num(get(hObject,'String'));
if isempty(requested_el)
    set(BEAMVIZ_GLOBAL.handles.el_box, 'String', sprintf( '%.2f', BEAMVIZ_GLOBAL.el ));
    return % Given azimuth invalid; ignore.
end
BEAMVIZ_GLOBAL.el = requested_el(1);
update_plot;



% --- Executes during object creation, after setting all properties.
function el_box_CreateFcn(hObject, eventdata, handles)
% hObject    handle to el_box (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function low_freq_box_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
requested_lo_freq = str2num( get(hObject,'String') )*1e3;
if isempty(requested_lo_freq) || requested_lo_freq < BEAMVIZ_GLOBAL.min_freq || requested_lo_freq >= BEAMVIZ_GLOBAL.beam_hi_freq
    set(hObject, 'String', sprintf( '%.2f', BEAMVIZ_GLOBAL.beam_lo_freq*1e-3 ));
    return
end
BEAMVIZ_GLOBAL.beam_lo_freq = requested_lo_freq;
bw = BEAMVIZ_GLOBAL.beam_hi_freq-BEAMVIZ_GLOBAL.beam_lo_freq; % in Hz
set(BEAMVIZ_GLOBAL.handles.bw_box, 'String', sprintf( '%.2f', bw*1e-3 ));
set(BEAMVIZ_GLOBAL.handles.freq_slider,'Min',(BEAMVIZ_GLOBAL.min_freq+bw/2)*1e-3);
set(BEAMVIZ_GLOBAL.handles.freq_slider,'Max',(BEAMVIZ_GLOBAL.max_freq-bw/2)*1e-3);
set(BEAMVIZ_GLOBAL.handles.freq_slider,'Value',[(BEAMVIZ_GLOBAL.beam_lo_freq+bw/2)*1e-3]);
update_plot;


% --- Executes during object creation, after setting all properties.
function low_freq_box_CreateFcn(hObject, eventdata, handles)
% hObject    handle to low_freq_box (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function high_freq_box_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
requested_hi_freq = str2num( get(hObject,'String') )*1e3;
if isempty(requested_hi_freq) || requested_hi_freq > BEAMVIZ_GLOBAL.max_freq || requested_hi_freq <= BEAMVIZ_GLOBAL.beam_lo_freq
    set(hObject, 'String', sprintf( '%.2f', BEAMVIZ_GLOBAL.beam_hi_freq*1e-3 ));
    return
end
BEAMVIZ_GLOBAL.beam_hi_freq = requested_hi_freq;
bw = BEAMVIZ_GLOBAL.beam_hi_freq-BEAMVIZ_GLOBAL.beam_lo_freq; % in Hz
set(BEAMVIZ_GLOBAL.handles.bw_box, 'String', sprintf( '%.2f', bw*1e-3 ));
set(BEAMVIZ_GLOBAL.handles.freq_slider,'Min',(BEAMVIZ_GLOBAL.min_freq+bw/2)*1e-3);
set(BEAMVIZ_GLOBAL.handles.freq_slider,'Max',(BEAMVIZ_GLOBAL.max_freq-bw/2)*1e-3);
set(BEAMVIZ_GLOBAL.handles.freq_slider,'Value',[(BEAMVIZ_GLOBAL.beam_lo_freq+bw/2)*1e-3]);
update_plot;


% --- Executes during object creation, after setting all properties.
function high_freq_box_CreateFcn(hObject, eventdata, handles)
% hObject    handle to high_freq_box (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --------------------------------------------------------------------
function Untitled_3_Callback(hObject, eventdata, handles)
% hObject    handle to Untitled_3 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function set_def_paths_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
req_path = uigetdir( '.', 'Select default directory for finding stuff.' );
if isequal(req_path,0)
    return % User hit Cancel button; ignore.
end
BEAMVIZ_GLOBAL.def_dir = req_path;


function update_plot( fig_h, ax_h )
global BEAMVIZ_GLOBAL;

% Ignore channels as requested by the user
T_start = BEAMVIZ_GLOBAL.T_start;
T_stop = BEAMVIZ_GLOBAL.T_stop;
F_start = BEAMVIZ_GLOBAL.F_start;
F_stop = BEAMVIZ_GLOBAL.F_stop;
for k = 1:length(BEAMVIZ_GLOBAL.ignore_ch)
    T_start(BEAMVIZ_GLOBAL.ignore_ch(k),:) = nan(1,BEAMVIZ_GLOBAL.num_vocs);
    T_stop(BEAMVIZ_GLOBAL.ignore_ch(k),:) = nan(1,BEAMVIZ_GLOBAL.num_vocs);
    F_start(BEAMVIZ_GLOBAL.ignore_ch(k),:) = nan(1,BEAMVIZ_GLOBAL.num_vocs);
    F_stop(BEAMVIZ_GLOBAL.ignore_ch(k),:) = nan(1,BEAMVIZ_GLOBAL.num_vocs);
end

I = find(~isnan( T_start(:,BEAMVIZ_GLOBAL.current_voc) ));
if isempty(I)
    fprintf( 'No channels marked for current vocalization. Ignoring gen-beam request.\n' );
    return % Ignore request if there's nothing to draw.
end

call_current_time = arr2bat;
current_rel_frame = floor(call_current_time*BEAMVIZ_GLOBAL.vid_fps) - BEAMVIZ_GLOBAL.vid_start_frame + 1;

if BEAMVIZ_GLOBAL.plot_type == 0 || BEAMVIZ_GLOBAL.plot_type == 1
    
    if BEAMVIZ_GLOBAL.plot_type == 0
        chan_vects = genbeam( BEAMVIZ_GLOBAL.mike_pos, BEAMVIZ_GLOBAL.G, ...
                              BEAMVIZ_GLOBAL.F, BEAMVIZ_GLOBAL.t, BEAMVIZ_GLOBAL.samp_period, ...
                              BEAMVIZ_GLOBAL.temp, BEAMVIZ_GLOBAL.rel_humid, ...
                              BEAMVIZ_GLOBAL.bat(current_rel_frame,:), T_start, T_stop, ...
                              [BEAMVIZ_GLOBAL.beam_lo_freq BEAMVIZ_GLOBAL.beam_hi_freq], ...
                              BEAMVIZ_GLOBAL.current_voc, 'RMS' );
    else % BEAMVIZ_GLOBAL.plot_type == 1
        chan_vects = genbeam( BEAMVIZ_GLOBAL.mike_pos, BEAMVIZ_GLOBAL.G, ...
                              BEAMVIZ_GLOBAL.F, BEAMVIZ_GLOBAL.t, BEAMVIZ_GLOBAL.samp_period, ...
                              BEAMVIZ_GLOBAL.temp, BEAMVIZ_GLOBAL.rel_humid, ...
                              BEAMVIZ_GLOBAL.bat(current_rel_frame,:), T_start, T_stop, ...
                              [BEAMVIZ_GLOBAL.beam_lo_freq BEAMVIZ_GLOBAL.beam_hi_freq], ...
                              BEAMVIZ_GLOBAL.current_voc, 'peak' );
    end

    I = find( ~isnan( chan_vects(:,1) ) );
    I_not = find( isnan( chan_vects(:,1) ) );
    if isempty(I)
        return % Failed to generate any beam vectors; drop out silently.
    end

    % Normalize chan_vect lengths
    cv_len = zeros(size(I));
    for k = 1:length(I)
        cv_len(k) = norm( chan_vects(I(k),:), 2 );
    end
    max_cv_len = max(cv_len);
    for k = 1:length(I)
        chan_vects(I(k),:) = chan_vects(I(k),:)/max_cv_len*2;
        %chan_vects(I(k),:) = chan_vects(I(k),:)/2;
    end
    max_dir = [0 0 0];
    for k = 1:length(I);
        max_dir = max_dir + chan_vects(I(k),:);
    end
    max_dir = max_dir/norm(max_dir,2)*2;
    max_dir_wrt_bat = [BEAMVIZ_GLOBAL.bat(current_rel_frame,:);
                       BEAMVIZ_GLOBAL.bat(current_rel_frame,:)+max_dir];

    chan_vects_full = zeros(length(I)*3,3); % For pretty plotting
    for k = 1:length(I)
        chan_vects_full((k-1)*3+2,:) = chan_vects(I(k),:);
        %chan_vects_full((k-1)*3+1:(k-1)*3+3,:) = chan_vects_full((k-1)*3+1:(k-1)*3+3,:) + [1;1;1]*BEAMVIZ_GLOBAL.mike_pos(I(k),:); % w.r.t. microphone
        chan_vects_full((k-1)*3+1:(k-1)*3+3,:) = chan_vects_full((k-1)*3+1:(k-1)*3+3,:) + [1;1;1]*BEAMVIZ_GLOBAL.bat(current_rel_frame,:); % w.r.t. bat
    end

    if nargin < 2
        ax_h = BEAMVIZ_GLOBAL.handles.axes_of_truth;
    else
        figure(fig_h); % Bring external figure window into focus.
    end

    % Patchy work to ease analysis of single target experiments
    target = BEAMVIZ_GLOBAL.objects(1).video(1,:);

    plot3( ax_h, ...
           BEAMVIZ_GLOBAL.bat(:,1), BEAMVIZ_GLOBAL.bat(:,2), BEAMVIZ_GLOBAL.bat(:,3), 'b-', ...
           BEAMVIZ_GLOBAL.bat(current_rel_frame,1), BEAMVIZ_GLOBAL.bat(current_rel_frame,2), BEAMVIZ_GLOBAL.bat(current_rel_frame,3), 'mo', ...
           target(1), target(2), target(3), 'kd', ...
           BEAMVIZ_GLOBAL.mike_pos(I,1), BEAMVIZ_GLOBAL.mike_pos(I,2), BEAMVIZ_GLOBAL.mike_pos(I,3), 'r*', ...
           BEAMVIZ_GLOBAL.mike_pos(I_not,1), BEAMVIZ_GLOBAL.mike_pos(I_not,2), BEAMVIZ_GLOBAL.mike_pos(I_not,3), 'yo', ...
           max_dir_wrt_bat(:,1),max_dir_wrt_bat(:,2),max_dir_wrt_bat(:,3),'k-' );
    hold( ax_h, 'on' );
    for k = 1:length(I)
        plot3( chan_vects_full((k-1)*3+1:(k-1)*3+3,1),chan_vects_full((k-1)*3+1:(k-1)*3+3,2),chan_vects_full((k-1)*3+1:(k-1)*3+3,3), 'md-' );
    end
    hold( ax_h, 'off' );
    axis( ax_h, 'equal' );
    grid( ax_h, 'on' );
    if ax_h ~= BEAMVIZ_GLOBAL.handles.axes_of_truth
        title( ax_h, sprintf( '%.2f - %.2f kHz; voc %d', BEAMVIZ_GLOBAL.beam_lo_freq/1e3, BEAMVIZ_GLOBAL.beam_hi_freq/1e3, BEAMVIZ_GLOBAL.current_voc ));
    end
    view( ax_h, BEAMVIZ_GLOBAL.az, BEAMVIZ_GLOBAL.el );
    
elseif BEAMVIZ_GLOBAL.plot_type == 2 ... % radial plot, using signal RMS, w.r.t. max length channel vector
       || BEAMVIZ_GLOBAL.plot_type == 4 % radial plot, using signal RMS, w.r.t. second object in d3_analysed structure (i.e. the "target").
    
    % Note that we orient the center of the beam-view to be the maximum
    % length vector (among those found by genbeam below).
    chan_vects = genbeam( BEAMVIZ_GLOBAL.mike_pos, BEAMVIZ_GLOBAL.G, ...
                          BEAMVIZ_GLOBAL.F, BEAMVIZ_GLOBAL.t, BEAMVIZ_GLOBAL.samp_period, ...
                          BEAMVIZ_GLOBAL.temp, BEAMVIZ_GLOBAL.rel_humid, ...
                          BEAMVIZ_GLOBAL.bat(current_rel_frame,:), T_start, T_stop, ...
                          [BEAMVIZ_GLOBAL.beam_lo_freq BEAMVIZ_GLOBAL.beam_hi_freq], ...
                          BEAMVIZ_GLOBAL.current_voc, 'RMS' );

	I = find( ~isnan( chan_vects(:,1) ) );
    I_not = find( isnan( chan_vects(:,1) ) );
    if isempty(I)
        return % Failed to generate any beam vectors; drop out silently.
    end

    % Normalize chan_vect lengths
    cv_len = zeros(size(I));
    for k = 1:length(I)
        cv_len(k) = norm( chan_vects(I(k),:), 2 );
    end
    [max_cv_len,max_cv_ind] = max(cv_len);
    for k = 1:length(I)
        chan_vects(I(k),:) = chan_vects(I(k),:)/max_cv_len;
    end
    
    % Switch to spherical coordinates, which will make re-orienting w.r.t.
    % some point easier
    [th,phi,r] = cart2sph( chan_vects(I,1), chan_vects(I,2), chan_vects(I,3) );
    
    % Select reference direction, depending on plot mode
    if BEAMVIZ_GLOBAL.plot_type == 2
        th_ref = th(max_cv_ind);
        phi_ref = phi(max_cv_ind);
    elseif BEAMVIZ_GLOBAL.plot_type == 4
        % We assume where target is in d3_analysed struct...
        % Patchy work to ease analysis of single target experiments
        bat2target = BEAMVIZ_GLOBAL.objects(1).video(1,:) - BEAMVIZ_GLOBAL.bat(current_rel_frame,:);
        %bat2target = BEAMVIZ_GLOBAL.mike_pos(7,:) - BEAMVIZ_GLOBAL.bat(current_rel_frame,:);
        [th_ref,phi_ref,r_ref] = cart2sph( bat2target(1), bat2target(2), bat2target(3) );
    else
        error( 'update_plot: FAIL.\n' ); % We shouldn't get to this point, anyway.
    end
    for k = 1:length(I)
        th(k) = th(k) - th_ref;
        phi(k) = phi(k) - phi_ref;
    end
    th = th*180/pi; % Convert to degrees
    phi = phi*180/pi;
    
    %tri = delaunay(th,phi);
    min_th = min(th);
    max_th = max(th);
    min_phi = min(phi);
    max_phi = max(phi);
    TH = min_th:(max_th-min_th)/30:max_th;
    PHI = min_phi:(max_phi-min_phi)/30:max_phi;
    R = surfinterp( th, phi, r, TH, PHI, 45 );
    
    if nargin < 2
        ax_h = BEAMVIZ_GLOBAL.handles.axes_of_truth;
    else
        figure(fig_h); % Bring external figure window into focus.
    end
    surf( ax_h, -TH, PHI, R, 'EdgeColor','none' );
    axis( ax_h, [-45 45 -45 45] );
    %axis( ax_h, 'tight' );
    %trisurf( tri, th*180/pi, phi*180/pi, 10*log10(r), ...
    %         'EdgeColor','none', 'Parent',ax_h );
    if ax_h ~= BEAMVIZ_GLOBAL.handles.axes_of_truth
        title( ax_h, sprintf( '%.2f - %.2f kHz; voc %d', BEAMVIZ_GLOBAL.beam_lo_freq/1e3, BEAMVIZ_GLOBAL.beam_hi_freq/1e3, BEAMVIZ_GLOBAL.current_voc ));
        xlabel('\theta (in deg)');
        ylabel('\phi (in deg)');
    end
    view( ax_h, BEAMVIZ_GLOBAL.az, BEAMVIZ_GLOBAL.el );
    
elseif BEAMVIZ_GLOBAL.plot_type == 3 % Simply show where the microphones are, given axis ranges that would be used for spherical plot
    
    % Note that we orient the center of the beam-view to be the maximum
    % length vector (among those found by genbeam below).
    chan_vects = genbeam( BEAMVIZ_GLOBAL.mike_pos, BEAMVIZ_GLOBAL.G, ...
                          BEAMVIZ_GLOBAL.F, BEAMVIZ_GLOBAL.t, BEAMVIZ_GLOBAL.samp_period, ...
                          BEAMVIZ_GLOBAL.temp, BEAMVIZ_GLOBAL.rel_humid, ...
                          BEAMVIZ_GLOBAL.bat(current_rel_frame,:), T_start, T_stop, ...
                          [BEAMVIZ_GLOBAL.beam_lo_freq BEAMVIZ_GLOBAL.beam_hi_freq], ...
                          BEAMVIZ_GLOBAL.current_voc, 'RMS' );

	I = find( ~isnan( chan_vects(:,1) ) );
    I_not = find( isnan( chan_vects(:,1) ) );
    if isempty(I)
        return % Failed to generate any beam vectors; drop out silently.
    end

    % Normalize chan_vect lengths
    cv_len = zeros(size(I));
    for k = 1:length(I)
        cv_len(k) = norm( chan_vects(I(k),:), 2 );
    end
    [max_cv_len,max_cv_ind] = max(cv_len);
    for k = 1:length(I)
        chan_vects(I(k),:) = chan_vects(I(k),:)/max_cv_len;
    end
    
    % Switch to spherical coorindates, which will make orienting w.r.t. the
    % max vector MUCH easier.
    [th,phi,r] = cart2sph( chan_vects(I,1), chan_vects(I,2), chan_vects(I,3) );
    for k = 1:length(I)
        th(k) = th(k) - th(max_cv_ind);
        phi(k) = phi(k) - phi(max_cv_ind);
    end
    th = th*180/pi; % Convert to degrees
    phi = phi*180/pi;
    
    if nargin < 2
        ax_h = BEAMVIZ_GLOBAL.handles.axes_of_truth;
    else
        figure(fig_h); % Bring external figure window into focus.
    end
    plot( ax_h, -th, phi, 'bo', 'LineWidth',4 );
    axis( ax_h, 'tight' );
    grid( ax_h, 'on' );
    if ax_h ~= BEAMVIZ_GLOBAL.handles.axes_of_truth
        title( ax_h, sprintf( '%.2f - %.2f kHz; voc %d; microphone positions', BEAMVIZ_GLOBAL.beam_lo_freq/1e3, BEAMVIZ_GLOBAL.beam_hi_freq/1e3, BEAMVIZ_GLOBAL.current_voc ));
        xlabel('\theta (in deg)');
        ylabel('\phi (in deg)');
    end
    view( ax_h, BEAMVIZ_GLOBAL.az, BEAMVIZ_GLOBAL.el );

elseif BEAMVIZ_GLOBAL.plot_type == 5 % radial plot, merging results from all marked vocalizations
    
    th = []; phi = []; r = [];
    for voc_ind = 1:BEAMVIZ_GLOBAL.num_vocs
        
        I = find(~isnan( T_start(:,voc_ind) ));
        if isempty(I)
            continue % Ignore this voc
        end

        call_current_time = arr2bat( voc_ind );
        current_rel_frame = floor(call_current_time*BEAMVIZ_GLOBAL.vid_fps) - BEAMVIZ_GLOBAL.vid_start_frame + 1;
    
        % Note that we orient the center of the beam-view to be the maximum
        % length vector (among those found by genbeam below).
        chan_vects = genbeam( BEAMVIZ_GLOBAL.mike_pos, BEAMVIZ_GLOBAL.G, ...
                              BEAMVIZ_GLOBAL.F, BEAMVIZ_GLOBAL.t, BEAMVIZ_GLOBAL.samp_period, ...
                              BEAMVIZ_GLOBAL.temp, BEAMVIZ_GLOBAL.rel_humid, ...
                              BEAMVIZ_GLOBAL.bat(current_rel_frame,:), T_start, T_stop, ...
                              [BEAMVIZ_GLOBAL.beam_lo_freq BEAMVIZ_GLOBAL.beam_hi_freq], ...
                              voc_ind, 'RMS' );

        I = find( ~isnan( chan_vects(:,1) ) );
        I_not = find( isnan( chan_vects(:,1) ) );
        if isempty(I)
            return % Failed to generate any beam vectors; drop out silently.
        end

        % Normalize chan_vect lengths
        cv_len = zeros(size(I));
        for k = 1:length(I)
            cv_len(k) = norm( chan_vects(I(k),:), 2 );
        end
        [max_cv_len,max_cv_ind] = max(cv_len);
        for k = 1:length(I)
            chan_vects(I(k),:) = chan_vects(I(k),:)/max_cv_len;
        end

        % Switch to spherical coorindates, which will make orienting w.r.t. the
        % max vector MUCH easier.
        % And grow data buffers to make room for new additions of this
        % vocalization.
        [th_add,phi_add,r_add] = cart2sph( chan_vects(I,1), chan_vects(I,2), chan_vects(I,3) );
        len_old_th = length(th);
        len_old_phi = length(phi);
        len_old_r = length(r);
        tmp_th = th;
        tmp_phi = phi;
        tmp_r = r;
        th = zeros(len_old_th+length(th_add),1);
        phi = zeros(len_old_phi+length(phi_add),1);
        r = zeros(len_old_r+length(r_add),1);
        th(1:len_old_th) = tmp_th;
        phi(1:len_old_phi) = tmp_phi;
        r = [tmp_r; r_add];
        for k = 1:length(I)
            th(len_old_th+k) = th_add(k) - th_add(max_cv_ind);
            phi(len_old_phi+k) = phi_add(k) - phi_add(max_cv_ind);
        end
        
    end
    th = th*180/pi; % Convert to degrees
    phi = phi*180/pi;
    
    %tri = delaunay(th,phi);
    min_th = min(th);
    max_th = max(th);
    min_phi = min(phi);
    max_phi = max(phi);
    TH = min_th:(max_th-min_th)/20:max_th;
    PHI = min_phi:(max_phi-min_phi)/20:max_phi;
    R = surfinterp( th, phi, r, TH, PHI, 50 );
    if nargin < 2
        ax_h = BEAMVIZ_GLOBAL.handles.axes_of_truth;
    else
        figure(fig_h); % Bring external figure window into focus.
    end
    surf( ax_h, -TH, PHI, R, 'EdgeColor','none' );
    axis( ax_h, 'tight' );
    %trisurf( tri, th*180/pi, phi*180/pi, 10*log10(r), ...
    %         'EdgeColor','none', 'Parent',ax_h );
    if ax_h ~= BEAMVIZ_GLOBAL.handles.axes_of_truth
        title( ax_h, sprintf( '%.2f - %.2f kHz; merged vocalizations', BEAMVIZ_GLOBAL.beam_lo_freq/1e3, BEAMVIZ_GLOBAL.beam_hi_freq/1e3 ));
        xlabel('\theta (in deg)');
        ylabel('\phi (in deg)');
    end
    view( ax_h, BEAMVIZ_GLOBAL.az, BEAMVIZ_GLOBAL.el );
    
else
    fprintf( 'Unimplemented plot type (given %d).\n', BEAMVIZ_GLOBAL.plot_type );
    return % Do nothing
end


function d3_filename_box_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
dmarks = strfind( BEAMVIZ_GLOBAL.d3_filename, '\' );
if isempty(dmarks)
    dmarks = [0];
end
set(BEAMVIZ_GLOBAL.handles.d3_filename_box, 'String', BEAMVIZ_GLOBAL.d3_filename(dmarks(end)+1:end) );


% --- Executes during object creation, after setting all properties.
function d3_filename_box_CreateFcn(hObject, eventdata, handles)
% hObject    handle to d3_filename_box (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


function array_filename_box_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
dmarks = strfind( BEAMVIZ_GLOBAL.array_filename, '\' );
if isempty(dmarks)
    dmarks = [0];
end
set(BEAMVIZ_GLOBAL.handles.array_filename_box, 'String', BEAMVIZ_GLOBAL.array_filename(dmarks(end)+1:end) );


% --- Executes during object creation, after setting all properties.
function array_filename_box_CreateFcn(hObject, eventdata, handles)
% hObject    handle to array_filename_box (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% Convert local call times on channels to most likely emission time at bat.
% Only non-NaN time values are used; returns empty matrix on error, or if
% no times are available on any mic channel.
%
% This was copied (almost) verbatim from radiance.m on 25 June 2010. --SCL
% ...And modified to support vocalization selection on 28 June 2010. --SCL
function [current_time] = arr2bat( current_voc )

global BEAMVIZ_GLOBAL;

if nargin < 1
    current_voc = BEAMVIZ_GLOBAL.current_voc;
end

bat_len = length(BEAMVIZ_GLOBAL.bat); % Assuming we have at least 3 bat positions.
bat_start_time = BEAMVIZ_GLOBAL.vid_start_frame/BEAMVIZ_GLOBAL.vid_fps;
mic_votes = nan(BEAMVIZ_GLOBAL.num_mics,1);
for k = 1:BEAMVIZ_GLOBAL.num_mics
    
    if isnan(BEAMVIZ_GLOBAL.T_start(k,BEAMVIZ_GLOBAL.current_voc))
        mic_votes(k) = NaN; % To be deleted before the election
    else
        
        if (bat_len-1)*BEAMVIZ_GLOBAL.samp_period + bat_start_time > BEAMVIZ_GLOBAL.T_start(k,current_voc)
            % Only consider source positions occurring at or before arrival
            % time at microphone
            N = max( ceil((BEAMVIZ_GLOBAL.T_start(k,current_voc) - bat_start_time)/BEAMVIZ_GLOBAL.samp_period), 1 );
        else
            N = bat_len;
        end

        min_ind = 1;
        min_err = abs( norm( BEAMVIZ_GLOBAL.mike_pos(k,:) - BEAMVIZ_GLOBAL.bat(min_ind,:), 2 ) ...
                       - BEAMVIZ_GLOBAL.spd_sound*(BEAMVIZ_GLOBAL.T_start(k,current_voc) - ((min_ind-1)/BEAMVIZ_GLOBAL.vid_fps+bat_start_time)) );
        for curr_ind = 2:N
            curr_err = abs( norm( BEAMVIZ_GLOBAL.mike_pos(k,:) - BEAMVIZ_GLOBAL.bat(curr_ind,:), 2 ) ...
                            - BEAMVIZ_GLOBAL.spd_sound*(BEAMVIZ_GLOBAL.T_start(k,current_voc) - ((curr_ind-1)/BEAMVIZ_GLOBAL.vid_fps+bat_start_time)) );
            if curr_err <= min_err
                min_ind = curr_ind;
                min_err = curr_err;
            end
        end

        mic_votes(k) = ((min_ind-1)/BEAMVIZ_GLOBAL.vid_fps+bat_start_time);
        
    end
    
end

% Currently, votes are equally weighted
I = find(isnan(mic_votes));
mic_votes(I) = []; % Delete not-a-number (NaN) entries.
current_time = mean( mic_votes );
return


% --------------------------------------------------------------------
function plot_nonbat_dialog_Callback(hObject, eventdata, handles)
fprintf('(Not yet implemented...)\n');
%...


% --------------------------------------------------------------------
function reload_rad_results_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
if isempty(BEAMVIZ_GLOBAL.rad_filename)
    fprintf( 'No session active. Ignoring reload request.\n' );
    return
end
fprintf( 'Re-reading %s file (on disk)...\n', BEAMVIZ_GLOBAL.rad_filename );
D = dir(BEAMVIZ_GLOBAL.rad_filename);
if isempty(D)
    fprintf( 'FAILED to find file. Please Open a new session.\n' );
    return
end

try
    rf = load('-MAT',BEAMVIZ_GLOBAL.rad_filename);
catch
    fprintf( 'Error occurred while attempting to open %s\n', BEAMVIZ_GLOBAL.rad_filename );
    return % error; do nothing.
end
if ~isfield(rf,'radiance_analysed')
    fprintf( 'File contents are invalid; failed to load %s\n', BEAMVIZ_GLOBAL.rad_filename );
    return % error
end
if all(all(isnan(rf.radiance_analysed.T_start)))
    fprintf( 'No vocalizations marked in given Radiance analysis file.\nIgnoring.\n' );
    return % abort loading
end

% Catch big changes and request a formal new "Open" process.
if BEAMVIZ_GLOBAL.num_mics ~= rf.radiance_analysed.num_mics
    fprintf( 'Number of microphone channels changed! Please start a new session.\n' );
    return
end

% Pull that shit in, and refresh plots and GUI handles of current beamviz
% session.
BEAMVIZ_GLOBAL.num_vocs = rf.radiance_analysed.num_vocs;
BEAMVIZ_GLOBAL.T_start = rf.radiance_analysed.T_start;
BEAMVIZ_GLOBAL.F_start = rf.radiance_analysed.F_start;
BEAMVIZ_GLOBAL.T_stop = rf.radiance_analysed.T_stop;
BEAMVIZ_GLOBAL.F_stop = rf.radiance_analysed.F_stop;

% If current voc is no longer present, reset everything to voc 1;
% otherwise, attempt to refresh as-is at current voc.
if BEAMVIZ_GLOBAL.current_voc > BEAMVIZ_GLOBAL.num_vocs
    BEAMVIZ_GLOBAL.plot_type = 0; % reset to "scene plot, RMS"
    BEAMVIZ_GLOBAL.current_voc = 1;
    set(BEAMVIZ_GLOBAL.handles.voc_num_box, 'String', num2str( BEAMVIZ_GLOBAL.current_voc ));
end
set(BEAMVIZ_GLOBAL.handles.voc_slider,'Min',1);
if BEAMVIZ_GLOBAL.num_vocs == 1
    set(BEAMVIZ_GLOBAL.handles.voc_slider,'Max',1.1);
else
    set(BEAMVIZ_GLOBAL.handles.voc_slider,'Max',BEAMVIZ_GLOBAL.num_vocs);
end
set(BEAMVIZ_GLOBAL.handles.voc_slider,'Value',[BEAMVIZ_GLOBAL.current_voc]);
update_plot;
fprintf('Done.\n');


% --------------------------------------------------------------------
function ignore_channels_dialog_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
if isempty(BEAMVIZ_GLOBAL.rad_filename)
    fprintf( 'No session active. Ignoring request.\n' );
    return
end

if isempty(BEAMVIZ_GLOBAL.ignore_ch)
    ignore_str = '';
else
    ignore_str = mat2str(BEAMVIZ_GLOBAL.ignore_ch);
end

answer = inputdlg( {'Enter mic channels to ignore:'}, ...
                   'Channel ignore for entire trial...', ...
                   1, {ignore_str} );
if isempty(answer)
    return % User hit cancel; do nothing.
end

ignore_ch = str2num(answer{1});

% Catch silly arguments
if (isempty(ignore_ch) && ~isempty(answer{1})) ...
   || (~isempty(ignore_ch) && any(ignore_ch(:) ~= fix(ignore_ch(:)))) ...l
   || (~isempty(ignore_ch) && (any(ignore_ch(:) < 1) || any(ignore_ch(:) > BEAMVIZ_GLOBAL.num_mics)))
    warndlg('Given ignore channels spec is invalid; it will be ignored.', 'Invalid input');
    return
end

ignore_ch = ignore_ch(:);
if size(ignore_ch,1) > size(ignore_ch,2)
    ignore_ch = ignore_ch'; % Ensure it's a row vector.
end
BEAMVIZ_GLOBAL.ignore_ch = ignore_ch;
update_plot;


% --- Executes on button press in voc_play_button.
function voc_play_button_Callback(hObject, eventdata, handles)
global BEAMVIZ_GLOBAL;
if get(hObject,'Value')
    play_vocs;
end


% Animation... with buffering!
function play_vocs

global BEAMVIZ_GLOBAL;
start_voc = BEAMVIZ_GLOBAL.current_voc;
stop_voc = BEAMVIZ_GLOBAL.num_vocs;

if stop_voc-start_voc > 10 % Try to be helpful.
    ButtonName=questdlg( sprintf('%d trials need to be buffered. Continue?',stop_voc-start_voc+1), ...
                         'Play vocalization sequences', 'Yes', 'No', 'No' );
    if ~strcmpi(ButtonName,'Yes')
        set(BEAMVIZ_GLOBAL.handles.voc_play_button,'Value',0);
        return
    end
end

fprintf( 'Buffering (if possible)...\n');

% Ignore channels as requested by the user
T_start = BEAMVIZ_GLOBAL.T_start;
T_stop = BEAMVIZ_GLOBAL.T_stop;
F_start = BEAMVIZ_GLOBAL.F_start;
F_stop = BEAMVIZ_GLOBAL.F_stop;
for k = 1:length(BEAMVIZ_GLOBAL.ignore_ch)
    T_start(BEAMVIZ_GLOBAL.ignore_ch(k),:) = nan(1,BEAMVIZ_GLOBAL.num_vocs);
    T_stop(BEAMVIZ_GLOBAL.ignore_ch(k),:) = nan(1,BEAMVIZ_GLOBAL.num_vocs);
    F_start(BEAMVIZ_GLOBAL.ignore_ch(k),:) = nan(1,BEAMVIZ_GLOBAL.num_vocs);
    F_stop(BEAMVIZ_GLOBAL.ignore_ch(k),:) = nan(1,BEAMVIZ_GLOBAL.num_vocs);
end

% We do the hard computational work of update_plot here, and then plot in
% the actual "play" loop.
chan_vects_full = cell(stop_voc-start_voc+1,1);
TH = cell(stop_voc-start_voc+1,1);
PHI = cell(stop_voc-start_voc+1,1);
R = cell(stop_voc-start_voc+1,1);
max_dir_wrt_bat = R;
I = R;
I_not = I;
current_rel_frame = R;
for current_voc = start_voc:stop_voc
    
    I{current_voc} = find(~isnan( T_start(:,current_voc) ));
    if isempty(I{current_voc})
        fprintf( 'No channels marked for current vocalization. Ignoring gen-beam request.\n' );
        return % Ignore request if there's nothing to draw.
    end

    call_current_time = arr2bat( current_voc );
    current_rel_frame{current_voc} = floor(call_current_time*BEAMVIZ_GLOBAL.vid_fps) - BEAMVIZ_GLOBAL.vid_start_frame + 1;

    if BEAMVIZ_GLOBAL.plot_type == 0 || BEAMVIZ_GLOBAL.plot_type == 1

        if BEAMVIZ_GLOBAL.plot_type == 0
            chan_vects = genbeam( BEAMVIZ_GLOBAL.mike_pos, BEAMVIZ_GLOBAL.G, ...
                                  BEAMVIZ_GLOBAL.F, BEAMVIZ_GLOBAL.t, BEAMVIZ_GLOBAL.samp_period, ...
                                  BEAMVIZ_GLOBAL.temp, BEAMVIZ_GLOBAL.rel_humid, ...
                                  BEAMVIZ_GLOBAL.bat(current_rel_frame{current_voc},:), T_start, T_stop, ...
                                  [BEAMVIZ_GLOBAL.beam_lo_freq BEAMVIZ_GLOBAL.beam_hi_freq], ...
                                  current_voc, 'RMS' );
        else % BEAMVIZ_GLOBAL.plot_type == 1
            chan_vects = genbeam( BEAMVIZ_GLOBAL.mike_pos, BEAMVIZ_GLOBAL.G, ...
                                  BEAMVIZ_GLOBAL.F, BEAMVIZ_GLOBAL.t, BEAMVIZ_GLOBAL.samp_period, ...
                                  BEAMVIZ_GLOBAL.temp, BEAMVIZ_GLOBAL.rel_humid, ...
                                  BEAMVIZ_GLOBAL.bat(current_rel_frame{current_voc},:), T_start, T_stop, ...
                                  [BEAMVIZ_GLOBAL.beam_lo_freq BEAMVIZ_GLOBAL.beam_hi_freq], ...
                                  current_voc, 'peak' );
        end

        I{current_voc} = find( ~isnan( chan_vects(:,1) ) );
        I_not{current_voc} = find( isnan( chan_vects(:,1) ) );
        if isempty(I{current_voc})
            return % Failed to generate any beam vectors; drop out silently.
        end

        % Normalize chan_vect lengths
        cv_len = zeros(size(I{current_voc}));
        for k = 1:length(I{current_voc})
            cv_len(k) = norm( chan_vects(I{current_voc}(k),:), 2 );
        end
        max_cv_len = max(cv_len);
        for k = 1:length(I{current_voc})
            chan_vects(I{current_voc}(k),:) = chan_vects(I{current_voc}(k),:)/max_cv_len*2;
            %chan_vects(I{current_voc}(k),:) = chan_vects(I{current_voc}(k),:)/2;
        end
        max_dir = [0 0 0];
        for k = 1:length(I{current_voc});
            max_dir = max_dir + chan_vects(I{current_voc}(k),:);
        end
        max_dir = max_dir/norm(max_dir,2)*2;
        max_dir_wrt_bat{current_voc} = [BEAMVIZ_GLOBAL.bat(current_rel_frame{current_voc},:);
                           BEAMVIZ_GLOBAL.bat(current_rel_frame{current_voc},:)+max_dir];

        chan_vects_full{current_voc} = zeros(length(I{current_voc})*3,3); % For pretty plotting
        for k = 1:length(I{current_voc})
            chan_vects_full{current_voc}((k-1)*3+2,:) = chan_vects(I{current_voc}(k),:);
            %chan_vects_full{current_voc}((k-1)*3+1:(k-1)*3+3,:) = chan_vects_full{current_voc}((k-1)*3+1:(k-1)*3+3,:) + [1;1;1]*BEAMVIZ_GLOBAL.mike_pos(I{current_voc}(k),:); % w.r.t. microphone
            chan_vects_full{current_voc}((k-1)*3+1:(k-1)*3+3,:) = chan_vects_full{current_voc}((k-1)*3+1:(k-1)*3+3,:) + [1;1;1]*BEAMVIZ_GLOBAL.bat(current_rel_frame{current_voc},:); % w.r.t. bat
        end

    elseif BEAMVIZ_GLOBAL.plot_type == 2 ... % radial plot, using signal RMS, w.r.t. max length channel vector
           || BEAMVIZ_GLOBAL.plot_type == 4 % radial plot, using signal RMS, w.r.t. second object in d3_analysed structure (i.e. the "target").

        % Note that we orient the center of the beam-view to be the maximum
        % length vector (among those found by genbeam below).
        chan_vects = genbeam( BEAMVIZ_GLOBAL.mike_pos, BEAMVIZ_GLOBAL.G, ...
                              BEAMVIZ_GLOBAL.F, BEAMVIZ_GLOBAL.t, BEAMVIZ_GLOBAL.samp_period, ...
                              BEAMVIZ_GLOBAL.temp, BEAMVIZ_GLOBAL.rel_humid, ...
                              BEAMVIZ_GLOBAL.bat(current_rel_frame{current_voc},:), T_start, T_stop, ...
                              [BEAMVIZ_GLOBAL.beam_lo_freq BEAMVIZ_GLOBAL.beam_hi_freq], ...
                              current_voc, 'RMS' );

        I{current_voc} = find( ~isnan( chan_vects(:,1) ) );
        I_not{current_voc} = find( isnan( chan_vects(:,1) ) );
        if isempty(I{current_voc})
            return % Failed to generate any beam vectors; drop out silently.
        end

        % Normalize chan_vect lengths
        cv_len = zeros(size(I{current_voc}));
        for k = 1:length(I{current_voc})
            cv_len(k) = norm( chan_vects(I{current_voc}(k),:), 2 );
        end
        [max_cv_len,max_cv_ind] = max(cv_len);
        for k = 1:length(I{current_voc})
            chan_vects(I{current_voc}(k),:) = chan_vects(I{current_voc}(k),:)/max_cv_len;
        end

        % Switch to spherical coordinates, which will make re-orienting w.r.t.
        % some point easier
        [th,phi,r] = cart2sph( chan_vects(I{current_voc},1), chan_vects(I{current_voc},2), chan_vects(I{current_voc},3) );

        % Select reference direction, depending on plot mode
        if BEAMVIZ_GLOBAL.plot_type == 2
            th_ref = th(max_cv_ind);
            phi_ref = phi(max_cv_ind);
        elseif BEAMVIZ_GLOBAL.plot_type == 4
            % We assume where target is in d3_analysed struct...
            % Patchy work to ease analysis of single target experiments
            %bat2target = BEAMVIZ_GLOBAL.objects(1).video(1,:) - BEAMVIZ_GLOBAL.bat(current_rel_frame,:);
            bat2target = BEAMVIZ_GLOBAL.mike_pos(7,:) - BEAMVIZ_GLOBAL.bat(current_rel_frame{current_voc},:);
            [th_ref,phi_ref,r_ref] = cart2sph( bat2target(1), bat2target(2), bat2target(3) );
        else
            error( 'update_plot: FAIL.\n' ); % We shouldn't get to this point, anyway.
        end
        for k = 1:length(I{current_voc})
            th(k) = th(k) - th_ref;
            phi(k) = phi(k) - phi_ref;
        end
        th = th*180/pi; % Convert to degrees
        phi = phi*180/pi;

        %tri = delaunay(th,phi);
        min_th = min(th);
        max_th = max(th);
        min_phi = min(phi);
        max_phi = max(phi);
        TH{current_voc} = min_th:(max_th-min_th)/30:max_th;
        PHI{current_voc} = min_phi:(max_phi-min_phi)/30:max_phi;
        R{current_voc} = surfinterp( th, phi, r, TH{current_voc}, PHI{current_voc}, 45 );

    elseif BEAMVIZ_GLOBAL.plot_type == 3 % Simply show where the microphones are, given axis ranges that would be used for spherical plot

        % Note that we orient the center of the beam-view to be the maximum
        % length vector (among those found by genbeam below).
        chan_vects = genbeam( BEAMVIZ_GLOBAL.mike_pos, BEAMVIZ_GLOBAL.G, ...
                              BEAMVIZ_GLOBAL.F, BEAMVIZ_GLOBAL.t, BEAMVIZ_GLOBAL.samp_period, ...
                              BEAMVIZ_GLOBAL.temp, BEAMVIZ_GLOBAL.rel_humid, ...
                              BEAMVIZ_GLOBAL.bat(current_rel_frame{current_voc},:), T_start, T_stop, ...
                              [BEAMVIZ_GLOBAL.beam_lo_freq BEAMVIZ_GLOBAL.beam_hi_freq], ...
                              current_voc, 'RMS' );

        I{current_voc} = find( ~isnan( chan_vects(:,1) ) );
        I_not{current_voc} = find( isnan( chan_vects(:,1) ) );
        if isempty(I{current_voc})
            return % Failed to generate any beam vectors; drop out silently.
        end

        % Normalize chan_vect lengths
        cv_len = zeros(size(I{current_voc}));
        for k = 1:length(I{current_voc})
            cv_len(k) = norm( chan_vects(I{current_voc}(k),:), 2 );
        end
        [max_cv_len,max_cv_ind] = max(cv_len);
        for k = 1:length(I{current_voc})
            chan_vects(I{current_voc}(k),:) = chan_vects(I{current_voc}(k),:)/max_cv_len;
        end

        % Switch to spherical coorindates, which will make orienting w.r.t. the
        % max vector MUCH easier.
        [th,phi,r] = cart2sph( chan_vects(I{current_voc},1), chan_vects(I{current_voc},2), chan_vects(I{current_voc},3) );
        for k = 1:length(I{current_voc})
            th(k) = th(k) - th(max_cv_ind);
            phi(k) = phi(k) - phi(max_cv_ind);
        end
        th{current_voc} = th*180/pi; % Convert to degrees
        phi{current_voc} = phi*180/pi;
        
    else
        fprintf( 'Animation not implemented for this plot type.\n' );
        return
    end
    
    fprintf( '%d ', current_voc );
    
end

fprintf( '\nDone buffering.\n' );

if stop_voc-start_voc > 10 % Try to be helpful.
    ButtonName=questdlg( sprintf('Buffering complete. Ready?',stop_voc-start_voc+1), ...
                         'Play vocalization sequences', 'Hell yeah!', 'No. Abort.', 'Hell yeah!' );
    if ~strcmpi(ButtonName,'Hell yeah!')
        set(BEAMVIZ_GLOBAL.handles.voc_play_button,'Value',0);
        return
    end
end

for current_voc = start_voc:stop_voc
    if get(BEAMVIZ_GLOBAL.handles.voc_play_button,'Value') == 0
        break;
    end
    
    % And now we do the plotting work avoided earlier while buffering
    if BEAMVIZ_GLOBAL.plot_type == 0 || BEAMVIZ_GLOBAL.plot_type == 1
        
        if nargin < 2
            ax_h = BEAMVIZ_GLOBAL.handles.axes_of_truth;
        else
            figure(fig_h); % Bring external figure window into focus.
        end

        % Patchy work to ease analysis of single target experiments
        target = [0 0 0];%BEAMVIZ_GLOBAL.objects(1).video(1,:);

        plot3( ax_h, ...
               BEAMVIZ_GLOBAL.bat(:,1), BEAMVIZ_GLOBAL.bat(:,2), BEAMVIZ_GLOBAL.bat(:,3), 'b-', ...
               BEAMVIZ_GLOBAL.bat(current_rel_frame{current_voc},1), BEAMVIZ_GLOBAL.bat(current_rel_frame{current_voc},2), BEAMVIZ_GLOBAL.bat(current_rel_frame{current_voc},3), 'mo', ...
               target(1), target(2), target(3), 'gd', ...
               BEAMVIZ_GLOBAL.mike_pos(I{current_voc},1), BEAMVIZ_GLOBAL.mike_pos(I{current_voc},2), BEAMVIZ_GLOBAL.mike_pos(I{current_voc},3), 'r*', ...
               BEAMVIZ_GLOBAL.mike_pos(I_not{current_voc},1), BEAMVIZ_GLOBAL.mike_pos(I_not{current_voc},2), BEAMVIZ_GLOBAL.mike_pos(I_not{current_voc},3), 'yo', ...
               max_dir_wrt_bat{current_voc}(:,1),max_dir_wrt_bat{current_voc}(:,2),max_dir_wrt_bat{current_voc}(:,3),'k-' );
        hold( ax_h, 'on' );
        for k = 1:length(I{current_voc})
            plot3( chan_vects_full{current_voc}((k-1)*3+1:(k-1)*3+3,1),chan_vects_full{current_voc}((k-1)*3+1:(k-1)*3+3,2),chan_vects_full{current_voc}((k-1)*3+1:(k-1)*3+3,3), 'md-' );
        end
        hold( ax_h, 'off' );
        axis( ax_h, 'equal' );
        grid( ax_h, 'on' );
        if ax_h ~= BEAMVIZ_GLOBAL.handles.axes_of_truth
            title( ax_h, sprintf( '%.2f - %.2f kHz; voc %d', BEAMVIZ_GLOBAL.beam_lo_freq/1e3, BEAMVIZ_GLOBAL.beam_hi_freq/1e3, current_voc ));
        end
        view( ax_h, BEAMVIZ_GLOBAL.az, BEAMVIZ_GLOBAL.el );
        
    elseif BEAMVIZ_GLOBAL.plot_type == 2 ... % radial plot, using signal RMS, w.r.t. max length channel vector
       || BEAMVIZ_GLOBAL.plot_type == 4 % radial plot, using signal RMS, w.r.t. second object in d3_analysed structure (i.e. the "target").
   
        if nargin < 2
            ax_h = BEAMVIZ_GLOBAL.handles.axes_of_truth;
        else
            figure(fig_h); % Bring external figure window into focus.
        end
        surf( ax_h, -TH{current_voc}, PHI{current_voc}, R{current_voc}, 'EdgeColor','none' );
        axis( ax_h, [-45 45 -45 45] );
        if ax_h ~= BEAMVIZ_GLOBAL.handles.axes_of_truth
            title( ax_h, sprintf( '%.2f - %.2f kHz; voc %d', BEAMVIZ_GLOBAL.beam_lo_freq/1e3, BEAMVIZ_GLOBAL.beam_hi_freq/1e3, current_voc ));
            xlabel('\theta (in deg)');
            ylabel('\phi (in deg)');
        end
        view( ax_h, BEAMVIZ_GLOBAL.az, BEAMVIZ_GLOBAL.el );
   
    elseif BEAMVIZ_GLOBAL.plot_type == 3 % Simply show where the microphones are, given axis ranges that would be used for spherical plot
   
        if nargin < 2
            ax_h = BEAMVIZ_GLOBAL.handles.axes_of_truth;
        else
            figure(fig_h); % Bring external figure window into focus.
        end
        plot( ax_h, -th{current_voc}, phi{current_voc}, 'bo', 'LineWidth',4 );
        axis( ax_h, 'tight' );
        grid( ax_h, 'on' );
        if ax_h ~= BEAMVIZ_GLOBAL.handles.axes_of_truth
            title( ax_h, sprintf( '%.2f - %.2f kHz; voc %d; microphone positions', BEAMVIZ_GLOBAL.beam_lo_freq/1e3, BEAMVIZ_GLOBAL.beam_hi_freq/1e3, current_voc ));
            xlabel('\theta (in deg)');
            ylabel('\phi (in deg)');
        end
        view( ax_h, BEAMVIZ_GLOBAL.az, BEAMVIZ_GLOBAL.el );
        
    end
    
    BEAMVIZ_GLOBAL.current_voc = current_voc;
    set(BEAMVIZ_GLOBAL.handles.voc_num_box,'String',num2str( BEAMVIZ_GLOBAL.current_voc ) );
    set(BEAMVIZ_GLOBAL.handles.voc_slider,'Value',BEAMVIZ_GLOBAL.current_voc );
    drawnow;
    pause(.7);
end
if current_voc == stop_voc
    set(BEAMVIZ_GLOBAL.handles.voc_play_button,'Value',0);
end
